# JavaScript的内存管理

低级语言，比如C，有低级的内存管理基元，像malloc(),free()。
JavaScript的内存基元在变量（对象，字符串等等）创建时分配，他们不再被使用时“自动”释放，这被称为垃圾回收。

在编写Javascript程序时，开发人员不用关心内存问题，内存分配及无用内存的回收完全实现了自动化管理。

### 内存分配操作
例：```javascript
<var n = 123; // 为数字分配内存
var s = "azerty"; // 为字符串分配内存 
var o = {  a: 1,  b: null}; // 为包含属性值的object对象分配内存 
var a = [1, null, "abra"]; // 为包含值的数组分配内存 
function f(a){  return a + 2;} // 为函数分配内存（函数是可调用的对象）
someElement.addEventListener('click', function(){ 
someElement.style.backgroundColor = 'blue';}, false);// 函数表达式同样也是对象，存在分配内存的情况
/>```
垃圾收集器会按照预定的时间间隔，周期性的找出那些不再继续使用的变量，然后释放其所占用的内存。具体到浏览器中，用于标识无用变量的策略，通常有两种：**标记清除和引用策略**

## 1. 标记清除

标记清除策略是Javascript中最常用的垃圾收集方式

### 标记清除的原理

当变量进入一个执行环境时，将这个变量标记为“进入环境”，当变量离开环境时，则将其标记为“离开环境”。垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记，然后它会去掉当前环境中的变量以及被环境中的变量引用的变量的标记，而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问这些变量了。最后，垃圾收集器完成内存清除的工作，销毁那些带标记的值并回收他们占据的内存空间。
使用这种方式，垃圾收集器可以获得所有可访问的对象，回收那些不可访问的对象。

## 2. 引用计数

引用计数的含义是跟踪记录每个值被引用的次数。当声明一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数便是1，如果同一个值又被赋给另 一个变量，则该值的引用次数加1，相反，如果包含对这个值引用的变量又取得了另一个值，则这个值的引用次数减1。当这个值的引用次数为0时，说明没有办法 访问到它了，因而可以将其占用的内存空间回收。

*引用计数策略遭遇的一个严重问题是**循环引用***

比如：
```javascript
<function memoryProblem ()  {
      var o1 = new Object();
      var o2 = new Object();
         o1.prop = o2;
         o2.prop = o1;
     }
  />
  ```
上面的代码中，当函数memoryProblem执行完毕后，o1和o2的引用次数不为0，最后得不到垃圾收集器的内存回收。  
### 循环引用导致内存泄漏 
例子：IE6、7中，在DOM对象上使用引用计数的算法，这里会存在内存泄露的问题
```javascript
<var div = document.createElement("div");
div.onclick = function(){
  doSomething();
}; // div 通过 click 属性引用了事件处理程序
// 当事件处理函数中访问了div变量的时候，会形成循环引用，将导致两个对象都不会被回收，造成内存泄露
/>
```
使用标记清除算法可有效改善内存泄漏问题，当div和事件处理函数被垃圾回收器标记为不可访问，他们就会被释放掉。
原文地址：this is an [https://developer.mozilla.org/en-US/docs/JavaScript/Memory_Management]
