# JavaScript的内存管理

低级语言，比如C，有低级的内存管理基元，像malloc(),free()。
JavaScript的内存基元在变量（对象，字符串等等）创建时分配，他们不再被使用时“自动”释放，这被称为垃圾回收。

*不管什么样的编程语言，内存的生命周期基本上是一致的。*

 1. *分配你需要的内存*
 2. *使用他进行读写操作*
 3. *当内存不需要的时候，释放资源*

*步骤1和步骤2对于所有语言都一样，能明显觉察到。至于步骤3，低级别语言需要开发者显式执行。而对于像javascript这样的高级语言，这部分操作是交给解析器完成的，所以你不会觉察到。*

在编写Javascript程序时，开发人员不用关心内存问题，内存分配及无用内存的回收完全实现了自动化管理。

### 内存分配操作
  例：
  1. 值初始化的内存分配
```javascript
<var n = 123; // 为数字分配内存
var s = "azerty"; // 为字符串分配内存 
var o = {  a: 1,  b: null}; // 为包含属性值的object对象分配内存 
var a = [1, null, "abra"]; // 为包含值的数组分配内存 
function f(a){  return a + 2;} // 为函数分配内存（函数是可调用的对象）
someElement.addEventListener('click', function(){ 
someElement.style.backgroundColor = 'blue';}, false);// 函数表达式同样也是对象，存在分配内存的情况
/>
```
  2. 函数调用的内存分配
```javascript
<var d = new Date();
var e = document.createElement('div'); // 分配一个 DOM 元素
/>
```

垃圾收集器会按照预定的时间间隔，周期性的找出那些不再继续使用的变量，然后释放其所占用的内存。具体到浏览器中，用于标识无用变量的策略，通常有两种：**标记清除和引用策略**，我们无法准确的做到自动判定“内存不再需要”。所以，垃圾回收对该问题的解决方案有局限性。

## 1. 标记清除

标记清除策略是Javascript中最常用的垃圾收集方式

### 标记清除的原理

当变量进入一个执行环境时，将这个变量标记为“进入环境”，当变量离开环境时，则将其标记为“离开环境”。垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记，然后它会去掉当前环境中的变量以及被环境中的变量引用的变量的标记，而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问这些变量了。最后，垃圾收集器完成内存清除的工作，销毁那些带标记的值并回收他们占据的内存空间。
使用这种方式，垃圾收集器可以获得所有可访问的对象，回收那些不可访问的对象。
***限制：对象需要明确的标记为不可访问***

## 2. 引用计数

引用计数的含义是跟踪记录每个值被引用的次数。当声明一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数便是1，如果同一个值又被赋给另 一个变量，则该值的引用次数加1，相反，如果包含对这个值引用的变量又取得了另一个值，则这个值的引用次数减1。当这个值的引用次数为0时，说明没有办法 访问到它了，因而可以将其占用的内存空间回收。
```javascript
<var o = { 
  a: {
    b:2
  }
}; // 创建了两个对象. 一个对象（a）被另外一个对象（o引用的对象）引用，并把a作为他的属性 // 该对象又被变量o引用 // 很明显，这时没有对象能被回收
 
var o2 = o; // 变量 o2 再次引用了该对象
o = 1; // o 不再引用该对象，只有o2还在引用该对象
var oa = o2.a; // oa引用 o2 的属性对象 a // 该对象被其他两个对象引用，分别是o2的属性a和oa变量
o2 = "yo"; // 该对象已经不再被其他对象引用了，但是他的属性a任然被oa变量引用，所以他还不能被释
oa = null; // 现在属性a也不再被别的对象引用，该对象可以被回收了
/>
```
*引用计数策略遭遇的一个严重问题是**循环引用***

比如：
```javascript
<function memoryProblem ()  {
      var o1 = new Object();
      var o2 = new Object();
         o1.prop = o2;
         o2.prop = o1;
     }
  />
  ```
上面的代码中，当函数memoryProblem执行完毕后，o1和o2的引用次数不为0，最后得不到垃圾收集器的内存回收。  
### 循环引用导致内存泄漏 
例子：IE6、7中，在DOM对象上使用引用计数的算法，这里会存在内存泄露的问题
```javascript
<var div = document.createElement("div");
div.onclick = function(){
  doSomething();
}; // div 通过 click 属性引用了事件处理程序
// 当事件处理函数中访问了div变量的时候，会形成循环引用，将导致两个对象都不会被回收，造成内存泄露
/>
```
使用标记清除算法可有效改善内存泄漏问题，当div和事件处理函数被垃圾回收器标记为不可访问，他们就会被释放掉。

***原文地址：this is an [https://developer.mozilla.org/en-US/docs/JavaScript/Memory_Management]***
